Rooms
========================================================

 .. image:: ../../gitImages/GameCommunicationDiagram_Room.png
	:alt: Chef's Hat Environment Diagram
	:align: center


The Rooms are available in two different settings: a local room, where the room and the agents run in the same process, and a remote room that allows the room and the agents to room in different processes.

While the local room is ideal for training and evaluating runing simulations on artificial agents, the remote room allows the agents to run on different machines, for example, which can extend the type of agents you can use.


Both rooms share the same game parameters:

.. list-table:: **Rooms parameters**
   :widths: auto
   :header-rows: 1

   * - Parameter
     - Description
     - Default Value
   * - room_name
     - name of the room, no special character is allowed
     - 
   * - game_type
     - The type of end game criteria game: "POINTS", based on score or "MATCHES", based on played matches. 
     - "MATCHES"
   * - stop_criteria
     - The max value of "POINTS" or "MATCHES" to determine the end of the game.
     - 10
   * - max_rounds
     - The maximum number of rounds per match, if -1, the players will play until all of them have 0 cards at hand.
     - -1
   * - verbose
     - room verbose
     - False
   * - save_dataset
     - If a dataset will be generated by the game environment
     - False  
   * - save_game_log
     - If a game log will be generated by the game environment
     - False  
   * - log_directory
     - The directory where the gamelog will be saved. If none, it will be saved in temp/
     - None
   * - timeout_player_response
     - Amount in seconds that the room will wait until a player do its action. If the timeout is reached, the player will perform a pass action.
     - 5          
     

Local Rooms
^^^^^^^^^^^^^^^^^^^
When initializing a local room, the room parameters have to be passed. As that implement the ChefsHatGym.agents.chefs_hat_agent.ChefsHatAgent class, have to be added. And the game can start, by calling the .start_new_game() function:

.. code-block:: python

	
	from ChefsHatGym.gameRooms.chefs_hat_room_local import ChefsHatRoomLocal
	from ChefsHatGym.env import ChefsHatEnv
	from ChefsHatGym.agents.agent_random import AgentRandon

	# Room parameters
	room_name = "Testing_1_Local"
	timeout_player_response = 5
	verbose = True

	# Game parameters
	game_type = ChefsHatEnv.GAMETYPE["POINTS"]
	stop_criteria = 15
	maxRounds = -1

	# Start the room
	room = ChefsHatRoomLocal(
		room_name,
		timeout_player_response=timeout_player_response,
		game_type=game_type,
		stop_criteria=stop_criteria,
		max_rounds=maxRounds,
		verbose=verbose,
		save_dataset=True,
		save_game_log=True
	)

	# Create the players
	p1 = AgentRandon(name="01")
	p2 = AgentRandon(name="02")
	p3 = AgentRandon(name="03")
	p4 = AgentRandon(name="04")

	# Adding players to the room
	for p in [p1, p2, p3, p4]:
		room.add_player(p)


	# Start the game
	info = room.start_new_game(game_verbose=True)

	print(f"Performance score: {info['performanceScore']}")
	print(f"Scores: {info['score']}")


In this example, both dataset and gamelog will be generated from the game environment. A log for the room will also be generated. After the game is played, a game summary dictionary is passed.


Remote Rooms
^^^^^^^^^^^^^^^^^^^^^^^^^^^^
	
 .. image:: ../../gitImages/GameCommunicationDiagram_Remote.png
	:alt: Chef's Hat Environment Diagram Remote room
	:align: center

To setup a remote room, besides using the room parameters, you have to set a url and port for the redis server, that will be responsible for controlling the communication between the room and the agents.

The remote room uses a pub/sub architecture to register players and send/request information from the agents. 

The remote room setup two channels for each agent connected to it, one to send and one to receive messages.

Before runing the remote room, guarantee that the Redis server is up and runing.


.. code-block:: python

	
	import time
	import redis
	from ChefsHatGym.gameRooms.chefs_hat_room_remote import ChefsHatRoomRemote
	from ChefsHatGym.env import ChefsHatEnv
	from ChefsHatGym.agents.agent_random import AgentRandon

	
	# Room parameters
	room_name = "Testing_1_Remote"
	timeout_player_subscribers = 200
	timeout_player_response = 5
	verbose = False
	redis_url= "localhost"
	redis_port = "6379"

	# Game parameters
	game_type = ChefsHatEnv.GAMETYPE["MATCHES"]
	stop_criteria = 3
	maxRounds = 10

	# Start the room
	room = ChefsHatRoomRemote(
		room_name,
		redis_url=redis_url,
		redis_port=redis_port,
		timeout_player_subscribers=timeout_player_subscribers,
		timeout_player_response=timeout_player_response,
		game_type=game_type,
		stop_criteria=stop_criteria,
		max_rounds=maxRounds,
		verbose=verbose,
	)

	# Give enought time for the room to setup
	time.sleep(1)

	# Create the players
	p1 = AgentRandon(name="01")
	p2 = AgentRandon(name="02")
	p3 = AgentRandon(name="03")
	p4 = AgentRandon(name="04")

	# Join agents
	for p in [p1, p2, p3, p4]:
		p.joinGame(room_name, redis_url=redis_url, redis_port=redis_port, verbose=False)

	# Start the game
	room.start_new_game(game_verbose=True)
	while not room.get_room_finished():
		time.sleep(1)


By using the agent.join() method, we are able to register the agent to the room, by passing the room_id. The remote room runs as a threaded method, in order to allow continuous communication with the agents, and will turn off as soon as the game is over.
The agent.join() also triggers the agent remote agent functionalities, allowing them to communicate with the redis pub/sub server. The agents will raise threaded listeners to allow communication with the room.